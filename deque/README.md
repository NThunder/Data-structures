### Deque

*Дек - структура данных, которая представляет собой последовательность элементов и позволяет осуществлять добавление/удаление элементов с обоих концов.*
В C++ дек включен в стандартную библиотеку в виде шаблонного класса `std::deque`. Особенностями его реализации являются следующие характеристики: 

* Амортизированная сложность операций `push_front`, `pop_front`, `push_back` и `pop_back` составляет O(1)
* Поддержана возможность обращения к элементам по индексу за O(1)
* Вместимость дека увеличивается динамически по мере необходимости.
* В отличие от вектора (`std::vector`) ссылки и указатели на объекты не инвалидируются.

Особого внимания заслуживает последний пункт. Инвалидация ссылок и указателей довольно распространенная проблема при работе с вектором. Она заключается в следующем. Допустим, мы сохранили ссылку/указатель на один из элементов вектора (`int& ref = v[1];`), а затем проводили некоторые манипуляции над вектором (в самом простом случае - добавляли новые элементы в конец). Изменится ли значение элемента `v[1]`? Естественно, нет - мы добавляли новые элементы, это не должно повлиять на уже существующие объекты. А что произойдет c `ref`? Добавление нового элемента потенциально может вызвать расширение буфера, которое заключается в копировании элементов в новый буфер и **удалении** старого. Таким образом, теперь `ref` ссылается на удаленный участок памяти более не принадлежащий нашей программе ("висячая/битая" ссылка), работа с `ref` потенциально опасна и приводит к UB. Шаблон `std::deque` этой проблемой не обладает и гарантирует валидность всех ссылок и указателей даже после расширения вместимости.


##### Детали реализации

Реализация шаблона `Deque`, упрощенный аналог `std::deque`, который обладает всеми вышеуказанными свойствами. Чтобы этого добиться, используется кольцевой буфер массивов фиксированной длины (страниц). Под буфером имеется в виду массив указателей на начало каждой из страниц. Элементы последовательно добавляются в конкретную страницу, после того как страница заполнена полностью, начинает заполняться другая страница. Если все страницы заполнены, то происходит увеличение массива страниц (согласно мультипликативной схеме описанной в **Vector**). При этом уже заполненные страницы не пересоздаются и не копируются, лишь перебрасываются указатели на них в новый буфер. Это позволяет получать быстрый доступ к каждому элементу по индексу (достаточно вычислить номер страницы и позицию элемента в ней), а так как данные хранятся только внутри страниц (которые не удаляются и не перевыделяются), то все ссылки и указатели остаются валидными.

Шаблон `Deque` с размером страницы в 100 элементов, в котором есть:

* Конструктор по умолчанию.
* Конструктор копирования.
* Оператор присваивания.
* Деструктор.
* метод `Swap(other)` - обменивает содержимое с другим массивом (`other` имеет тип `Deque`)
* Константный и неконстантный оператор доступа по индексу []. Неконстантный позволяет изменять полученный элемент (`a[1] = 5`);
* метод `Size()`, возвращающий число элементов в деке.
* метод `PushBack(value)` - добавляет элемент value в конец массива
* метод `PopBack()` - удаляет последний элемент
* методы `PushFront` и `PopFront`.
* метод `Clear()` - устанавливает размер в 0, деаллокации выделенной памяти при этом НЕ происходит
