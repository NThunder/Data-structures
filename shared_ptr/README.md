### SharedPtr and WeakPtr

*Умные указатели реализуют важную идиому C++ - RAII (Resource 
Acquisition Is Initialization) и позволяют не заботиться о ручном 
управлении памятью, так как инкапсулируют управление ресурсами 
посредством конструкторов и деструкторов.*

#### `std::shared_ptr` (C++11)

Шаблонный класс `std::shared_ptr` предоставляет интерфейс указателя на данные в динамической области с автоматическим контролем своевременного выделения и удаления ресурсов. В отличие от `std::unique_ptr`, `std::shared_ptr` реализует семантику *разделяемого владения ресурсом*, что означает, что у одного ресурса может быть несколько равноправных владельцев. При этом гарантируется, что ресурс не будет освобожден пока существует хотя бы один его владелец (хотя бы один объект `std::shared_ptr` указывает на ресурс). Для решения проблемы *циклических ссылок* в язык также введены "слабые указатели" `std::weak_ptr`, которые не считаются полноценными владельцами ресурса, но из них при необходимости можно получить "сильный указатель" `std::shared_ptr` на объект, если тот еще не удален.

Несмотря на то, что `std::shared_ptr` удобнее в использовании чем `std::unique_ptr`, на практике последний работает гораздо эффективней - `std::shared_ptr` реализует дополнительную логику с подсчетом ссылок на объект. Поэтому `std::shared_ptr` стоит использовать только тогда, когда вам действительно нужно разделяемое владение.

Реализация шаблона `SharedPtr` - упрощенный аналог класса умного
указателя с разделяемым владением и
шаблон `WeakPtr` - аналог `std::weak_ptr`.

#### Детали реализации

Шаблонный класс `SharedPtr` поддерживает:
* Конструктор по умолчанию (создает нулевой указатель)
* Конструктор от указателя (сохраняет указатель на владеемый объект)
* Конструктор копирования и копирующее присваивание (создают новую ссылку на тот же объект)
* Перемещающий конструктор и перемещающее присваивание передают владение объектом
* Конструктор от `WeakPtr`
* Метод `Reset(T* ptr = nullptr)`, меняет указатель, которым владеет
объект
* Метод `Swap(SharedPtr<T>&)`
* Метод `Get()`, возвращающий указатель на владеемый объект
* Метод `UseCount()`, возвращающий число "сильных" ссылок на объект
* Оператор разыменовывания `operator*`
* Оператор "стрелочка" `operator->`
* Явный оператор приведения к `bool` (`operator bool`)

Шаблон `WeakPtr` состоит из:
* Аналогичных конструкторов и операторов присваивания
* Конструктора от `SharedPtr`
* Метода `Swap(WeakPtr<T>&)`
* Метода `Reset()`, отвязывающего указатель от объекта
* Метода `UseCount()`, возвращающего число "сильных" ссылок на объект
* Метод `Expired()`, возвращающий `true`, если сильных ссылок на объект уже нет (объект удален)
* Метод `Lock()`, возвращающий `SharedPtr` на объект (если `Expired() == true`, то возвращается пустой указатель)

Конструктор `SharedPtr` от `WeakPtr` работает аналогично методу 
`Lock()`, но в случае `Expired() == true` бросается исключение
`BadWeakPtr`

1. https://en.cppreference.com/w/cpp/memory/shared_ptr

2. https://en.cppreference.com/w/cpp/memory/weak_ptr

Также реализована внешняя шаблонная функция
`MakeShared`, принимающая произвольное число параметров и
возвращающая `SharedPtr` на объект созданный с помощью данных
параметров конструктора. На практике `std::make_shared` 
позволяет выделить счетчики и объект единым блоком в памяти, что
часто повышает эффективность программы.
