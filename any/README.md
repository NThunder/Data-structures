### Any

Упрощенный аналог класса `std::any`
реализованный с помощью упрощённого динамического полиморфизма.

#### std::any (C++17)
В C++17 появился класс, позволяющий хранить в себе объекты
произвольных типов. Ровно как в динамически типизированных
языках, типа Python, одна и та же переменная может использоваться
для хранения разных типов (`a = "aba"; a = 3;` - валидный код),
так и переменная типа `std::any` может хранить в себе данные разных типов
 (формально, конечно, ее тип всегда будет оставаться `std::any`).
 
 Но C++ - статически типизированный язык, поэтому "за удовольствие приходится платить".
 Во-первых, дополнительными накладными расходами, а, во-вторых, удобством использования.
 Например, нельзя просто так взять и присвоить значение `std::any` другой переменной,
  даже если тип ее текущего значения совпадает с типом принимающей стороны. Для получения значения конкретного типа
   необходимо явно попросить об этом с помощью шаблонной функции `std::any_cast<T>`, где 
   `T` - требуемый тип. В случае, если в данный момент объект содержит не тип `T`,
   бросается исключение `std::bad_any_cast`.
   
Полезные методы: `reset()` - обнуляет объект, делая его пустым; 
`swap(std::any&)` - обменивает содержимое; `has_value()` - `true`, если объект не пуст, `false` иначе;
внешняя шаблонная функция `std::make_any<T>(args...)` - принимает аргументы конструктора, с которым
нужно создать объект типа `T` и возвращает `std::any` с этим объектом. (https://en.cppreference.com/w/cpp/utility/any).

#### Детали реализации 

Полиморфный базовый класс `Base`
и шаблонный класс `Derived<T>` - наследник Base, который будет хранить в себе единственное поле типа `T` - требуемое значение.
`Derived` поддерживает конструктор от `T`, чтобы инициализировать поле.
Основной класс `Any` имеет:
*  Поле-указатель (умный) на `Base`.
* Конструктор по умолчанию, выставляющий указатель в `nullptr` (пустой объект)
* Конструктор копирования,
который возвращает указатель на `Base`, на новый выделенный объект.
* Шаблонный конструктор от объекта произвольного типа `T` (который должен хранить объект `Any`).
* Аналогичный оператор присваивания.
* Методы `Swap(Any& other)`, `Reset()` и `HasValue()`.

Также реализован класс исключения `BadAnyCast`, и внешняя шаблонная функция
`template <class T> T AnyCast(const Any& value)`, которая возвращает значение, в случае, если `Base` указывает
на `Derived<T>` и бросает `BadAnyCast` в противном случае.

**Замечания.**

1. Класс активно работает с кучей и механизмом позднего связывания, что может существенно влиять на производительность, поэтому его стоит использовать с осторожностью.
